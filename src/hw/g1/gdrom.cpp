/*
 * nejicast is a Sega Dreamcast emulator.
 * Copyright (C) 2025  noumidev
 */

#include <hw/g1/gdrom.hpp>

#include <cassert>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>

#include <scheduler.hpp>
#include <hw/holly/intc.hpp>

namespace hw::g1::gdrom {

enum : u32 {
    IO_GD_ALT_STATUS    = 0x005F7018,
    IO_GD_DEV_CONTROL   = 0x005F7018,
    IO_GD_DATA          = 0x005F7080,
    IO_GD_FEATURES      = 0x005F7084,
    IO_GD_SECTOR_COUNT  = 0x005F7088,
    IO_GD_SECTOR_NUMBER = 0x005F708C,
    IO_GD_BYTE_COUNT_LO = 0x005F7090,
    IO_GD_BYTE_COUNT_HI = 0x005F7094,
    IO_GD_STATUS        = 0x005F709C,
    IO_GD_COMMAND       = 0x005F709C,
};

#define GD_DEV_CONTROL   ctx.device_control
#define GD_STATUS        ctx.status
#define GD_REASON        ctx.interrupt_reason
#define GD_SECTOR_NUMBER ctx.sector_number
#define GD_BYTE_COUNT    ctx.byte_count

constexpr usize NUM_DATA_IN_BYTES = 12;

struct {
    std::vector<u8> data_in_bytes, data_out_bytes;
    usize data_out_ptr;

    union {
        u8 raw;

        struct {
            u8 check             : 1;
            u8                   : 1;
            u8 correctable_error : 1;
            u8 data_request      : 1;
            u8 seek_completed    : 1;
            u8 drive_fault       : 1;
            u8 data_ready        : 1;
            u8 busy              : 1;
        };
    } status;

    union {
        u8 raw;

        struct {
            u8                   : 1;
            u8 disable_interrupt : 1;
            u8                   : 6;
        };
    } device_control;

    union {
        u8 raw;

        struct {
            u8 is_command  : 1;
            u8 from_device : 1;
            u8             : 6;
        };
    } interrupt_reason;

    union {
        u8 raw;

        struct {
            u8 sense_key   : 4;
            u8 disc_format : 4;
        };
    } sector_number;

    union {
        u16 raw;

        struct {
            u8 lo;
            u8 hi;
        };
    } byte_count;
} ctx;

static void reset_data_in_buffer() {
    std::vector<u8> temp;

    ctx.data_in_bytes.swap(temp);
}

[[maybe_unused]]
static void reset_data_out_buffer() {
    std::vector<u8> temp;

    ctx.data_out_bytes.swap(temp);

    ctx.data_out_ptr = 0;
}

constexpr int GDROM_INTERRUPT = 0;

static void finish_non_data_command() {
    GD_STATUS.busy = 0;

    hw::holly::intc::assert_external_interrupt(GDROM_INTERRUPT);
}

static void prepare_packet_transfer() {
    reset_data_in_buffer();

    GD_STATUS.busy = 0;
    GD_STATUS.data_request = 1;

    GD_REASON.is_command = 1;
    GD_REASON.from_device = 0;
}

static void ata_packet() {
    std::puts("ATA PACKET");

    prepare_packet_transfer();
}

static void ata_set_features() {
    std::puts("ATA SET_FEATURES");

    finish_non_data_command();
}

enum {
    ATA_COMMAND_PACKET       = 0xA0,
    ATA_COMMAND_SET_FEATURES = 0xEF,
};

static void execute_ata_command(const int command) {
    switch (command) {
        case ATA_COMMAND_PACKET:
            ata_packet();
            break;
        case ATA_COMMAND_SET_FEATURES:
            ata_set_features();
            break;
        default:
            std::printf("Unhandled ATA command %02d\n", command);
            exit(1);
    }
}

static void finish_spi_non_data_command() {
    GD_REASON.is_command = 1;
    GD_REASON.from_device = 1;

    GD_STATUS.busy = 0;
    GD_STATUS.data_request = 0;
    GD_STATUS.data_ready = 1;

    hw::holly::intc::assert_external_interrupt(GDROM_INTERRUPT);
}

static void finish_spi_host_pio_command(const u16 size) {
    GD_REASON.is_command = 0;
    GD_REASON.from_device = 1;

    GD_STATUS.busy = 0;
    GD_STATUS.data_request = 1;

    GD_BYTE_COUNT.raw = size;

    hw::holly::intc::assert_external_interrupt(GDROM_INTERRUPT);
}

static void finish_host_pio_transfer() {
    GD_REASON.is_command = 1;
    GD_REASON.from_device = 1;
    
    GD_STATUS.busy = 0;
    GD_STATUS.data_request = 0;
    GD_STATUS.data_ready = 1;

    hw::holly::intc::assert_external_interrupt(GDROM_INTERRUPT);
}

enum {
    SENSE_KEY_NO_SENSE,
};

enum {
    DISC_FORMAT_GDROM = 8,
};

static void spi_test_unit() {
    std::puts("SPI TEST_UNIT");

    GD_SECTOR_NUMBER.sense_key = SENSE_KEY_NO_SENSE;
    GD_SECTOR_NUMBER.disc_format = DISC_FORMAT_GDROM;

    finish_spi_non_data_command();
}

#define SPI_STARTING_ADDRESS  ctx.data_in_bytes[2]
#define SPI_ALLOCATION_LENGTH ctx.data_in_bytes[4]

static void spi_req_mode() {
    // Taken from washingtonDC
    constexpr u8 DATA[0x20] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0xb4, 0x19, 0x00,
    0x00, 0x08,  'S',  'E',  ' ',  ' ',  ' ',  ' ',
    ' ',  ' ',  'R',  'e',  'v',  ' ',  '6',  '.',
    '4',  '2',  '9',  '9',  '0',  '3',  '1',  '6'
    };

    std::printf("SPI REQ_MODE (address: %u, length: %u)\n", SPI_STARTING_ADDRESS, SPI_ALLOCATION_LENGTH);

    assert((SPI_STARTING_ADDRESS + SPI_ALLOCATION_LENGTH) < sizeof(DATA));

    reset_data_out_buffer();

    for (u8 i = 0; i < SPI_ALLOCATION_LENGTH; i++) {
        ctx.data_out_bytes.push_back(DATA[SPI_STARTING_ADDRESS + i]);
    }

    finish_spi_host_pio_command(SPI_ALLOCATION_LENGTH);
}

static void spi_init() {
    std::puts("SPI INIT");

    finish_spi_non_data_command();
}

static void spi_71() {
    // Taken from washingtonDC
    constexpr u8 DATA[] = {
        0x42, 0x07, 0xF0, 0x47, 0x07, 0x1B, 0x10, 0xED, 0x05, 0xBC,
        0xC0, 0x00, 0x06, 0x08, 0x94, 0x78, 0x6A, 0x0A, 0x4B, 0x00,
        0x46, 0x0E, 0xDD, 0xC4, 0xA8, 0x38, 0x82, 0xB1, 0xFC, 0xD5,
        0x5E, 0x2A, 0xB7, 0x00, 0x9A, 0x0B, 0xEC, 0x1D, 0xBE, 0x85,
        0x5C, 0x96, 0xF4, 0x82, 0x00, 0x69, 0x0A, 0x9E, 0x34, 0xE7,
        0x3D, 0x9F, 0x22, 0x83, 0x00, 0x09, 0x0F, 0x3F, 0x7C, 0x26,
        0x83, 0x28, 0xBF, 0x6D, 0xB3, 0x23, 0x0F, 0x07, 0x42, 0x00,
        0xE1, 0x07, 0xD8, 0xFE, 0x23, 0xFC, 0x00, 0x00, 0x04, 0x67,
        0x00, 0x30, 0x03, 0x00, 0xCA, 0x08, 0x55, 0x75, 0xE0, 0xBF,
        0x92, 0x00, 0xED, 0x05, 0x36, 0x7B, 0x00, 0x9A, 0x0C, 0x08,
        0xB1, 0x79, 0x88, 0x13, 0xCE, 0xEC, 0x96, 0x00, 0x00, 0xCD,
        0x04, 0x68, 0x00, 0xA6, 0x03, 0x00, 0x89, 0x0E, 0x22, 0xD2,
        0x32, 0x4C, 0x8F, 0x97, 0xD2, 0x7D, 0xC0, 0x41, 0x7E, 0x00,
        0x51, 0x0E, 0x63, 0xC0, 0xD0, 0x82, 0x12, 0xE6, 0x93, 0x90,
        0xC2, 0xA0, 0xA3, 0x00, 0x15, 0x06, 0xC3, 0x97, 0x5C, 0x00,
        0xF1, 0x03, 0x00, 0x0B, 0x03, 0x00, 0x55, 0x04, 0xC3, 0x00,
        0x88, 0x0B, 0x9E, 0x41, 0x2B, 0x4B, 0x2D, 0x5A, 0xCE, 0x2B,
        0x00, 0x67, 0x0C, 0xB8, 0x0D, 0xC4, 0x53, 0x63, 0xDC, 0x65,
        0xA2, 0xA6, 0x00, 0x61, 0x0C, 0x96, 0x18, 0xD6, 0xEB, 0x66,
        0xA9, 0x05, 0x29, 0xF0, 0x00, 0xDD, 0x0B, 0x79, 0x9D, 0xD9,
        0x9E, 0xDB, 0x35, 0x03, 0x14, 0x00, 0xCB, 0x04, 0xE0, 0x00,
        0x51, 0x08, 0x5F, 0xFC, 0x14, 0x6A, 0x6C, 0x00, 0x60, 0x10,
        0xA6, 0xDE, 0x2C, 0x8F, 0x38, 0x6D, 0x28, 0xD6, 0xC4, 0x8A,
        0xE8, 0xCB, 0xEC, 0x00, 0x3C, 0x11, 0x01, 0xE6, 0x1D, 0x80,
        0xAA, 0x1B, 0x22, 0x2E, 0x0E, 0x0D, 0xF5, 0x29, 0x51, 0xE3,
        0x00, 0x60, 0x07, 0xB6, 0x4D, 0x4E, 0x3C, 0x00, 0x22, 0x05,
        0x5A, 0xB9, 0x00, 0x9B, 0x08, 0x9B, 0x70, 0xB6, 0xBD, 0x29,
        0x00, 0x1A, 0x06, 0xFE, 0x3A, 0xBE, 0x00, 0x0A, 0x09, 0xF6,
        0x38, 0xB1, 0xB5, 0x1D, 0xA1, 0x00, 0x45, 0x0E, 0xE5, 0xC0,
        0xD2, 0x62, 0x62, 0xE1, 0x98, 0x70, 0x01, 0x1B, 0x11, 0x00,
        0x4A, 0x05, 0xBE, 0xBD, 0x00, 0xCB, 0x0C, 0xF5, 0xA0, 0xA4,
        0x4C, 0x2E, 0xEA, 0x17, 0x9E, 0x37, 0x00, 0x6C, 0x0E, 0xB0,
        0xBF, 0xCA, 0x1F, 0xE9, 0x22, 0xC5, 0x49, 0xB7, 0x7E, 0x6F,
        0x00, 0x4F, 0x10, 0xEC, 0xEA, 0x92, 0xC5, 0x5C, 0x72, 0x6A,
        0x6F, 0x5D, 0x95, 0xAC, 0x8F, 0xCB, 0x00, 0x81, 0x0F, 0x12,
        0xBA, 0x67, 0x89, 0x0F, 0xB2, 0x97, 0xBF, 0x93, 0x59, 0xC4,
        0xBA, 0x00, 0x7B, 0x09, 0x4C, 0xC3, 0xDD, 0xD8, 0xD8, 0x5E,
        0x00, 0xD3, 0x11, 0x06, 0x2D, 0xFF, 0x81, 0x8F, 0x49, 0x3B,
        0xE0, 0x93, 0x41, 0xEC, 0x01, 0x5D, 0x7F, 0x00, 0xFF, 0x0C,
        0x6E, 0xDE, 0xF0, 0x89, 0x50, 0x92, 0x6B, 0xCA, 0xD9, 0x00,
        0x8F, 0x0A, 0x10, 0xE3, 0xC0, 0x20, 0x69, 0xBE, 0x5B, 0xF9,
        0x5F, 0xB5, 0x81, 0x0F, 0x89, 0xC9, 0x96, 0xC8, 0x8B, 0x6E,
        0x6C, 0x41, 0xA0, 0xE7, 0x83, 0xC0, 0x6B, 0x9C, 0xDB, 0x43,
        0xBD, 0x34, 0x2A, 0x40, 0xF9, 0x6B, 0xF2, 0xC9, 0xA5, 0xDD,
        0xCE, 0x58, 0xBF, 0xA7, 0xF9, 0xCB, 0xCE, 0xF7, 0x6D, 0xC9,
        0xE5, 0xF6, 0x90, 0x87, 0x1C, 0x5B, 0xE0, 0xD0, 0xEA, 0x55,
        0x2E, 0xA0, 0x19, 0x7E, 0x2B, 0x07, 0xF6, 0xDA, 0x16, 0xBE,
        0xFB, 0x9F, 0x5B, 0xC2, 0x89, 0x76, 0xB1, 0x19, 0xCB, 0x28,
        0xE0, 0x9B, 0xB2, 0x86, 0x15, 0x1D, 0x1B, 0xAC, 0x15, 0xF2,
        0x75, 0x18, 0xB3, 0xE7, 0xE2, 0x2F, 0xFD, 0xFD, 0x1E, 0x83,
        0x1A, 0xB5, 0x2C, 0x45, 0xE9, 0x4A, 0x44, 0x0A, 0x72, 0xFF,
        0x40, 0x34, 0xBB, 0xF8, 0xE0, 0x16, 0xED, 0x32, 0x9C, 0xFC,
        0x0A, 0xF9, 0xBC, 0x93, 0xA4, 0x46, 0x73, 0x16, 0xD9, 0x3F,
        0x32, 0xA7, 0xA7, 0xCC, 0xE8, 0xAC, 0xE0, 0xBA, 0xA6, 0xFF,
        0x30, 0xE9, 0x10, 0x19, 0xE8, 0x7C, 0x5C, 0x20, 0x43, 0x9C,
        0xBC, 0xE7, 0x24, 0xDF, 0x51, 0x73, 0x0E, 0x60, 0x5D, 0x3D,
        0x6A, 0x8A, 0x64, 0x73, 0xCF, 0x57, 0x24, 0xA2, 0x10, 0x64,
        0xBA, 0xCD, 0xEF, 0x00, 0x40, 0x23, 0xD5, 0xDD, 0x42, 0x31,
        0x38, 0x13, 0xB9, 0x9C, 0xD5, 0xA8, 0x43, 0x34, 0xFD, 0x91,
        0x88, 0x3E, 0xAA, 0x42, 0x45, 0x63, 0xFA, 0x10, 0xD9, 0xC5,
        0xA7, 0x7F, 0xDE, 0x12, 0x64, 0xA9, 0x2E, 0x88, 0x0A, 0xA9,
        0x30, 0xDA, 0x63, 0xCC, 0xB5, 0x2C, 0xE0, 0x22, 0x2E, 0x6C,
        0x5D, 0x14, 0xC9, 0x4B, 0xBD, 0x3B, 0xEF, 0xDD, 0x9C, 0x97,
        0xF5, 0x4D, 0xD3, 0x99, 0x01, 0x5E, 0xB0, 0xED, 0xE7, 0xA9,
        0xC8, 0x21, 0x06, 0x91, 0x34, 0x74, 0x75, 0x5F, 0x85, 0x0A,
        0x74, 0x1D, 0x74, 0x42, 0xD0, 0x5A, 0xAC, 0x45, 0x11, 0x06,
        0xF9, 0x41, 0xA1, 0x61, 0xE1, 0x0F, 0xD4, 0xD2, 0x98, 0x41,
        0xB7, 0x81, 0x9D, 0x24, 0xF8, 0x40, 0xA0, 0x87, 0x7B, 0x63,
        0x8F, 0xAA, 0xCC, 0x96, 0x9E, 0xB4, 0xAC, 0x72, 0xB8, 0xF2,
        0x8A, 0xDE, 0x55, 0xA6, 0xF2, 0x47, 0x84, 0xE2, 0x99, 0xF4,
        0xD4, 0xEE, 0xE4, 0x22, 0x7B, 0xCA, 0x51, 0xDE, 0xA4, 0x1C,
        0xAE, 0x3A, 0x8D, 0x1F, 0x7C, 0x1B, 0xEC, 0xFB, 0x6F, 0x9A,
        0x8B, 0xF2, 0x39, 0xA4, 0x6D, 0xC9, 0x9D, 0x7B, 0xA9, 0x2E,
        0xEF, 0xC2, 0xE3, 0x5F, 0xB5, 0x55, 0x1D, 0xAD, 0x1A, 0x83,
        0xC8, 0xB1, 0x03, 0x1E, 0x67, 0x98, 0xA5, 0xB1, 0x39, 0x29,
        0xAA, 0x09, 0x39, 0x6B, 0x05, 0x12, 0x0B, 0x85, 0x6D, 0x26,
        0xAD, 0xA4, 0xC4, 0x21, 0x54, 0xFD, 0x37, 0x6F, 0xB8, 0xE4,
        0x76, 0x3B, 0xC2, 0x46, 0xF0, 0x82, 0xB9, 0xCE, 0x9F, 0x5B,
        0xBE, 0x18, 0x0E, 0x83, 0x81, 0x4B, 0xFE, 0xC2, 0x0B, 0xB8,
        0x1E, 0xAE, 0xF5, 0x36, 0x0D, 0x8D, 0xEF, 0xBD, 0x2E, 0xE5,
        0xDF, 0xD7, 0x12, 0xDE, 0x6B, 0x92, 0xFB, 0xB6, 0xEA, 0xBA,
        0x14, 0x49, 0x7A, 0xB5, 0x08, 0xFF, 0xAF, 0x8E, 0x14, 0xC7,
        0x0E, 0x7A, 0x41, 0xD3, 0x05, 0x9F, 0x29, 0xE4, 0xDB, 0x5E,
        0x87, 0x03, 0xE4, 0xE5, 0x47, 0x75, 0x9E, 0x59, 0x7B, 0x82,
        0x9C, 0x70, 0xAE, 0x44, 0xAA, 0xA4, 0x6D, 0x22, 0x31, 0x6E,
        0x64, 0x0B, 0xE2, 0xD0, 0x5E, 0xDC, 0xF3, 0x2D, 0x97, 0xF6,
        0xF4, 0xA2, 0x3B, 0x68, 0x1E, 0xA4, 0x9B, 0x36, 0x0B, 0x64,
        0x92, 0x8D, 0x5D, 0xA6, 0x63, 0x03, 0x98, 0x71, 0x75, 0x29,
        0xAC, 0xFC, 0x4D, 0xE5, 0x6A, 0xE5, 0xC8, 0x7C, 0xC7, 0xA3,
        0xDA, 0x68, 0x4E, 0x17, 0xF0, 0x0F, 0x13, 0x08, 0xE1, 0xA7,
        0x0C, 0xFC, 0xAD, 0x08, 0xC2, 0x68, 0xBE, 0xFD, 0x66, 0x79,
        0x14, 0x77, 0x66, 0xF4, 0x1C, 0x8C, 0x54, 0x24, 0x78, 0x0F,
        0x91, 0x93, 0x55, 0x64, 0x58, 0x96, 0xE0, 0x55, 0xE4, 0xFB,
        0x45, 0x9B, 0x0B, 0xFC, 0x15, 0x35, 0x96, 0x59, 0xC9, 0xDE,
        0x91, 0xA4, 0x04, 0xB8, 0x12, 0x47, 0x13, 0xEA, 0xBF, 0x5A,
        0x2F, 0xBE, 0x24, 0xE6, 0x62, 0x71, 0xF1, 0xB1, 0xF3, 0x8D
    };

    std::puts("SPI 71");

    reset_data_out_buffer();

    for (u8 i : DATA) {
        ctx.data_out_bytes.push_back(i);
    }

    finish_spi_host_pio_command(sizeof(DATA));
}

#define SPI_COMMAND ctx.data_in_bytes[0]

enum {
    SPI_COMMAND_TEST_UNIT = 0x00,
    SPI_COMMAND_REQ_MODE  = 0x11,
    SPI_COMMAND_INIT      = 0x70, // ??
    SPI_COMMAND_71        = 0x71, // ????
};

static void execute_spi_command(const int command) {
    assert(ctx.data_in_bytes.size() == NUM_DATA_IN_BYTES);

    switch (command) {
        case SPI_COMMAND_TEST_UNIT:
            spi_test_unit();
            break;
        case SPI_COMMAND_REQ_MODE:
            spi_req_mode();
            break;
        case SPI_COMMAND_INIT:
            spi_init();
            break;
        case SPI_COMMAND_71:
            spi_71();
            break;
        default:
            std::printf("Unhandled SPI command %02d\n", command);
            exit(1);
    }
}

void initialize() {}

void reset() {
    std::memset(&ctx, 0, sizeof(ctx));
}

void shutdown() {}

template<typename T>
T read(const u32 addr) {
    std::printf("Unmapped GD-ROM read%zu @ %08X\n", 8 * sizeof(T), addr);
    exit(1);
}

template<>
u8 read(const u32 addr) {
    switch (addr) {
        case IO_GD_ALT_STATUS:
            std::puts("GD_ALT_STATUS read8");

            return GD_STATUS.raw;
        case IO_GD_SECTOR_NUMBER:
            std::puts("GD_SECTOR_NUMBER read8");

            return GD_SECTOR_NUMBER.raw;
        case IO_GD_BYTE_COUNT_LO:
            std::puts("GD_BYTE_COUNT_LO read8");

            return GD_BYTE_COUNT.lo;
        case IO_GD_BYTE_COUNT_HI:
            std::puts("GD_BYTE_COUNT_HI read8");

            return GD_BYTE_COUNT.hi;
        case IO_GD_STATUS:
            std::puts("GD_STATUS read8");

            hw::holly::intc::clear_external_interrupt(GDROM_INTERRUPT);

            return GD_STATUS.raw;
        default:
            std::printf("Unmapped GD-ROM read8 @ %08X\n", addr);
            exit(1);
    }
}

template<>
u16 read(const u32 addr) {
    switch (addr) {
        case IO_GD_DATA:
            {
                std::puts("GD_DATA read16");

                u16 data = ctx.data_out_bytes[ctx.data_out_ptr++];

                if (ctx.data_out_ptr < ctx.data_out_bytes.size()) {
                    data |= ctx.data_out_bytes[ctx.data_out_ptr++] << 8;
                }

                if (ctx.data_out_ptr == ctx.data_out_bytes.size()) {
                    finish_host_pio_transfer();
                }

                return data;
            }
        default:
            std::printf("Unmapped GD-ROM read16 @ %08X\n", addr);
            exit(1);
    }
}

template u32 read(u32);
template u64 read(u32);

template<typename T>
void write(const u32 addr, const T data) {
    std::printf("Unmapped GD-ROM write%zu @ %08X = %0*llX\n", 8 * sizeof(T), addr, (int)(2 * sizeof(T)), (u64)data);
    exit(1);
}

template<>
void write(const u32 addr, const u8 data) {
    switch (addr) {
        case IO_GD_DEV_CONTROL:
            std::printf("GD_DEV_CONTROL write8 = %02X\n", data);

            GD_DEV_CONTROL.raw = data;
            break;
        case IO_GD_FEATURES:
            std::printf("GD_FEATURES write8 = %02X\n", data);
            break;
        case IO_GD_SECTOR_COUNT:
            std::printf("GD_SECTOR_COUNT write8 = %02X\n", data);
            break;
        case IO_GD_BYTE_COUNT_LO:
            std::printf("GD_BYTE_COUNT_LO write8 = %02X\n", data);

            GD_BYTE_COUNT.lo = data;
            break;
        case IO_GD_BYTE_COUNT_HI:
            std::printf("GD_BYTE_COUNT_HI write8 = %02X\n", data);

            GD_BYTE_COUNT.hi = data;
            break;
        case IO_GD_COMMAND:
            std::printf("GD_COMMAND write8 = %02X\n", data);

            // Unsure about the timings of all the commands, so we'll just delay them by a bit
            scheduler::schedule_event("ATA", execute_ata_command, data, 4096);

            GD_STATUS.busy = 1;
            break;
        default:
            std::printf("Unmapped GD-ROM write8 @ %08X = %02X\n", addr, data);
            exit(1);
    }
}

template<>
void write(const u32 addr, const u16 data) {
    switch (addr) {
        case IO_GD_DATA:
            std::printf("GD_DATA write16 = %04X\n", data);

            assert(ctx.data_in_bytes.size() < NUM_DATA_IN_BYTES);

            ctx.data_in_bytes.push_back(data);
            ctx.data_in_bytes.push_back(data >> 8);

            if (ctx.data_in_bytes.size() >= NUM_DATA_IN_BYTES) {
                scheduler::schedule_event("SPI", execute_spi_command, SPI_COMMAND, 4096);

                GD_STATUS.busy = 1;
                GD_STATUS.data_request = 0;
            }
            break;
        default:
            std::printf("Unmapped GD-ROM write16 @ %08X = %04X\n", addr, data);
            exit(1);
    }
}

template void write(u32, u32);
template void write(u32, u64);

}
